import{_ as t,o as i,c as a,a2 as o}from"./chunks/framework.BS-IksUQ.js";const f=JSON.parse('{"title":"Features","description":"","frontmatter":{"title":"Features"},"headers":[],"relativePath":"guide/features.md","filePath":"guide/features.md"}'),r={name:"guide/features.md"};function n(l,e,s,d,c,u){return i(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h1><h2 id="stl-file-i-o" tabindex="-1">STL File I/O <a class="header-anchor" href="#stl-file-i-o" aria-label="Permalink to &quot;STL File I/O&quot;">​</a></h2><ul><li>Load ASCII or binary STL files from disk</li><li>Automatic format detection (<code>guess_format=.true.</code>) — no need to know the file format upfront</li><li>Load with on-the-fly clipping: <code>clip_min</code> / <code>clip_max</code> bounding box arguments discard facets outside the box during load</li><li>Save surfaces to ASCII or binary STL</li></ul><h2 id="surface-analysis" tabindex="-1">Surface Analysis <a class="header-anchor" href="#surface-analysis" aria-label="Permalink to &quot;Surface Analysis&quot;">​</a></h2><p>After calling <code>surface%analize</code>, the following data are computed and stored:</p><ul><li>Axis-aligned bounding box (<code>bmin</code>, <code>bmax</code>)</li><li>Enclosed volume (<code>volume</code>) and centroid (<code>centroid</code>)</li><li>Facet connectivity — which facets share each edge</li><li>Disconnected-edge detection: facets with 1, 2, or 3 disconnected edges are catalogued separately</li><li>AABB octree built automatically for acceleration</li></ul><h2 id="surface-manipulation" tabindex="-1">Surface Manipulation <a class="header-anchor" href="#surface-manipulation" aria-label="Permalink to &quot;Surface Manipulation&quot;">​</a></h2><p>All manipulation methods operate directly on <code>surface_stl_object</code>:</p><ul><li><strong>Translate</strong> — by a 3D vector (<code>delta=</code>) or by scalar components (<code>x=</code>, <code>y=</code>, <code>z=</code>)</li><li><strong>Rotate</strong> — around an arbitrary axis by angle in radians, or by a given rotation matrix</li><li><strong>Mirror</strong> — with respect to a plane defined by its normal, or by a given mirror matrix</li><li><strong>Resize (scale)</strong> — by a 3D vector factor or by scalar per-axis factors; optionally scale about the surface centroid</li><li><strong>Clip</strong> — discard facets outside an axis-aligned bounding box; the cut-off remainder is returned as a separate surface</li><li><strong>Merge</strong> — combine two STL surfaces into one (<code>merge_solids</code>)</li><li><strong>Sanitize normals</strong> — make all facet normals consistent (outward or inward)</li><li><strong>Reverse normals</strong> — flip all facet normals</li><li><strong>Connect nearby vertices</strong> — repair disconnected edges by snapping nearby vertices together</li></ul><h2 id="distance-and-point-in-polyhedra-queries" tabindex="-1">Distance and Point-in-Polyhedra Queries <a class="header-anchor" href="#distance-and-point-in-polyhedra-queries" aria-label="Permalink to &quot;Distance and Point-in-Polyhedra Queries&quot;">​</a></h2><ul><li>Minimum unsigned (squared or Euclidean) distance from a point to the surface</li><li>Signed distance (negative inside, positive outside) via: <ul><li>Solid angle computation</li><li>Ray intersection counting</li></ul></li><li>Point-in-polyhedron test via solid angle or ray intersection</li><li><code>compute_mesh_distance</code> — compute distance from each node of a structured mesh block to the STL surface</li><li>All distance queries benefit from AABB octree acceleration (up to 7× speedup over brute force)</li></ul><h2 id="aabb-octree-acceleration" tabindex="-1">AABB Octree Acceleration <a class="header-anchor" href="#aabb-octree-acceleration" aria-label="Permalink to &quot;AABB Octree Acceleration&quot;">​</a></h2><p>The Axis-Aligned Bounding Box (AABB) octree is built automatically during <code>analize</code>. It uses 8-child (octree) subdivision and is embedded directly in <code>surface_stl_object%aabb</code>. The refinement depth is user-configurable and reported in <code>statistics()</code>.</p><h2 id="fossilizer-cli" tabindex="-1"><code>fossilizer</code> CLI <a class="header-anchor" href="#fossilizer-cli" aria-label="Permalink to &quot;`fossilizer` CLI&quot;">​</a></h2><p>A command-line utility (<code>src/app/fossilizer.f90</code>) wraps the library for interactive STL processing:</p><ul><li>Load one or more STL files</li><li>Apply clip, merge, mirror, rotate, translate, resize, sanitize, and connectivity repair operations</li><li>Print per-file statistics to stdout</li><li>Save the result to a named output file</li></ul><h2 id="compiler-support" tabindex="-1">Compiler Support <a class="header-anchor" href="#compiler-support" aria-label="Permalink to &quot;Compiler Support&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Compiler</th><th>Status</th></tr></thead><tbody><tr><td>GNU gfortran ≥ 5.3</td><td>Supported</td></tr><tr><td>Intel Fortran ≥ 16.x</td><td>Supported</td></tr><tr><td>NVIDIA HPC Fortran (nvfortran)</td><td>Supported</td></tr><tr><td>IBM XL Fortran</td><td>Not tested</td></tr><tr><td>g95</td><td>Not tested</td></tr><tr><td>NAG Fortran</td><td>Not tested</td></tr></tbody></table><h2 id="design-principles" tabindex="-1">Design Principles <a class="header-anchor" href="#design-principles" aria-label="Permalink to &quot;Design Principles&quot;">​</a></h2><ul><li><strong>Pure Fortran</strong> — no C extensions, no system calls beyond standard I/O</li><li><strong>OOP</strong> — all functionality exposed as type-bound procedures on three well-defined types</li><li><strong>TDD</strong> — every public operation is exercised by automated tests in <code>src/tests/</code></li><li><strong>KISS</strong> — simple, focused API without unnecessary abstractions</li><li><strong>Free &amp; Open Source</strong> — multi-licensed for both FOSS and commercial use</li></ul>',20)])])}const h=t(r,[["render",n]]);export{f as __pageData,h as default};
